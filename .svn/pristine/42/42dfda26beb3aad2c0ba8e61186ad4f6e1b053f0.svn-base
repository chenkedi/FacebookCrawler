package api.facebook.method;


import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import org.apache.http.HttpEntity;
import org.apache.http.ParseException;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.util.EntityUtils;
import org.apache.log4j.Logger;
import org.json.JSONObject;

import api.facebook.http.ClientFactory;
import api.facebook.http.ProxyClient;
import api.facebook.util.JsonAnalyze;

/**
 * 封装graphAPI中获取公共主页的贴文、评论和涂鸦墙信息的方法和数据解析
 * @author chenkedi
 *
 */
public abstract class GraphAPI
{
	private final static String BASE_URL="graph.facebook.com";
	private final static String clientId="1628625687408087";
	private final static String clientSecret="878b93ffea9985a0835dc9442756e05b";
	//private Map<String,String> accessToken=null;
	protected JsonAnalyze json=new JsonAnalyze();
	private ClientFactory clientFactory=new ProxyClient();//通过这里来确定制造何种类型的client（normal or proxy）
	protected static final Logger log =  Logger
			.getLogger(GraphAPI.class);
	

	/**
	 * 由于从API获取的comments、feeds、posts的数据字段大相径庭，所以定义抽象的数据抽取方法，将具体的数据抽取和转换的知识封装在子类中
	 * @return
	 */
//	public abstract AbstractBean dataExtract();
	
	/**
	 * 根据所给的node和要获取的fields请求API,获得返回的HTML实体的json对象
	 * @param node 公共主页名 或者 一条post的id，或者 一条feed的id
	 * @param fields posts、comments、feeds
	 * @return JSONObject
	 */
	public JSONObject callAPI(String node,String fields){
		
		CloseableHttpClient httpClient=clientFactory.createClient();
		
		//动态创建API链接地址
		URI uri=null;
		try {
			uri = new URIBuilder()
			.setScheme("https")
			.setHost(BASE_URL)
			.setPath("/"+node)
			.setParameter("fields", fields)
			.setParameter("access_token", clientId+"|"+clientSecret)
			.build();
		} catch (URISyntaxException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		//请求URL并获取response
		CloseableHttpResponse response= getResponse(httpClient,uri);
		//获得请求的实体
		HttpEntity entity = response.getEntity();
		//打印请求状态
		log.info("获取 "+node+"的 "+fields+" 属性的状态："+response.getStatusLine().toString());
		//将实体转为字符串
		String entityString=getEntityString(entity);
		log.info("================获得的json对象==========");
		try{
		log.info(entityString.substring(0,200));
		}catch(Exception e){
			log.error("当请求"+node+"的"+fields+"属性时，字符串截取超过返回的json字符串的长度");
			log.info(entityString);
			log.error(e.getMessage());
		}
		JSONObject jsonObject=new JSONObject(entityString);

		return jsonObject;
	}
	
	
	/**
	 * 根据首次遍历所获得的翻页链接,获得返回的HTML实体的json对象
	 * @param node 公共主页名 或者 一条post的id，或者 一条feed的id
	 * @param fields posts、comments、feeds
	 * @return JSONObject
	 */
	public JSONObject callAPI(String node,String fields,String url){
		
		CloseableHttpClient httpClient=clientFactory.createClient();
		
		//编码链接
		URI uri=null;
		url=url.replaceAll("\\|", "%7c");
		try {
			uri = new URIBuilder(url).build();
		} catch (URISyntaxException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
			
		//请求URL并获取response
		CloseableHttpResponse response= getResponse(httpClient,uri);
		//获得请求的实体
		HttpEntity entity = response.getEntity();
		//打印请求状态
		log.info("获取 "+node+"的 "+fields+" 属性的状态："+response.getStatusLine().toString());
		//将实体转为字符串
		String entityString=getEntityString(entity);
		log.info("================获得的json对象==========");
		try{
		log.info(entityString.substring(0, 200));
		}catch(Exception e){
			log.error("当请求"+node+"的"+fields+"属性时，字符串截取超过返回的json字符串的长度");
			log.info(entityString);
			log.error(e.getMessage());
			}
		JSONObject jsonObject=new JSONObject(entityString);

		return jsonObject;
	}
	
	/**
	 * 根据APP ID 和 APP Secret 获取APP类型的AccessToken
	 * 后期优化需要将APP ID 和 APP Secret队列写入配置文件
	 * @return
	 */
	public Map<String,String> obtainAccessToken(){
		
		CloseableHttpClient httpClient=clientFactory.createClient();//这里创建的是ProxyClient
		
		//动态创建API链接地址
		URI uri=null;
		try {
			uri = new URIBuilder()
			.setScheme("https")
			.setHost(BASE_URL)
			.setPath("/oauth/access_token")
			.setParameter("client_id", clientId)
			.setParameter("client_secret", clientSecret)
			.setParameter("grant_type", "client_credentials")
			.build();
		} catch (URISyntaxException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		//请求URL并获取response
		CloseableHttpResponse response= getResponse(httpClient,uri);
		//获得请求的实体
		HttpEntity entity = response.getEntity();
		//打印请求状态
		log.info("获取access token状态："+response.getStatusLine().toString());
		//将实体转为字符串
		String entityString=getEntityString(entity);

//		JSONObject jsonObject=new JSONObject(entityString);
		Map<String,String> map=new HashMap<String,String>();
//		//如果请求没有成功，则返回错误信息和错误code
//		if(json.isErrorJson(jsonObject)){
//			map=json.jsonErrorMessage(jsonObject);
//		}else{
//			List<String> keys=new ArrayList();
//			keys.add("access_token");
//			map=json.jsonLeafObjectAnalyze(jsonObject, keys);
//		}
		String[] entityArray=entityString.split("=");
		map.put(entityArray[0], entityArray[1]);
		return map;
	}
	
	
	/**
	 * 封装公用的请求URL并返回response对象，并进行异常处理的过程
	 * @param httpClient
	 * @param uri
	 * @return
	 */
	public CloseableHttpResponse getResponse(CloseableHttpClient httpClient, URI uri){
		
		HttpGet httpGet=new HttpGet(uri);
		//开始请求API
		log.info("==================请求的URL=====================");
		log.info(uri.toString());
		CloseableHttpResponse response = null;
		try {
			response = httpClient.execute(httpGet);
		} catch (ClientProtocolException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}catch(Exception e){
			log.info("未知的ssl错误，应该是remote host closed connection during handshake");
			log.info("可能是代理断开，睡眠5分钟: "+e.getMessage());
			try {
				Thread.sleep(3600*60*5);
			} catch (InterruptedException e1) {
				e1.printStackTrace();
			}
		}
		return response;
	}
	
	/**
	 * 封装公用的http实体转字符串，并进行异常处理的过程
	 * @param entity
	 * @return
	 */
	public String getEntityString(HttpEntity entity){
		
		String entityString=null;
		try {
			entityString= EntityUtils.toString(entity, "utf-8");
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return entityString;
	}
	
	/**
	 * 获取当前时间的时间戳，用于获取insert_time
	 */
	public Timestamp getNowTime(){
		
		return new Timestamp(System.currentTimeMillis());
	}
	
	/**
	 * 字符串转时间戳
	 * @param time
	 * @param format
	 * @return
	 */
	public Timestamp string2Timestamp(String time,String format){
		
		Timestamp ts=null;
		if(format!=null){
			SimpleDateFormat sf = new SimpleDateFormat(format);
			
			Date date=null;
			try {
				date = sf.parse(time);
			} catch (java.text.ParseException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			ts = new Timestamp(date.getTime());
		}else{
			
			String[] times=time.split("T");
			String[] hours=times[1].split("\\+");
			time=times[0]+" "+hours[0];
			ts=Timestamp.valueOf(time);
		}
		
		return ts;
		
	}
}
